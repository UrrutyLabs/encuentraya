// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "./generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  client
  pro
  admin
}


enum PaymentProvider {
  MERCADO_PAGO
}

enum PaymentType {
  PREAUTH
}

enum PaymentStatus {
  CREATED
  REQUIRES_ACTION
  AUTHORIZED
  CAPTURED
  FAILED
  CANCELLED
  REFUNDED
}

enum ProStatus {
  pending
  active
  suspended
}

// Category enum removed - now using data-driven Category model

enum PreferredContactMethod {
  EMAIL
  WHATSAPP
  PHONE
}

enum NotificationChannel {
  EMAIL
  WHATSAPP
  PUSH
}

enum NotificationDeliveryStatus {
  QUEUED
  SENT
  FAILED
}

enum PushProvider {
  EXPO
}

enum DevicePlatform {
  IOS
  ANDROID
}

enum PayoutMethod {
  BANK_TRANSFER
}

enum EarningStatus {
  PENDING
  PAYABLE
  PAID
  REVERSED
}

enum PayoutProvider {
  MERCADO_PAGO
  BANK_TRANSFER
  MANUAL
}

enum PayoutStatus {
  CREATED
  SENT
  FAILED
  SETTLED
}

enum AuditEventType {
  PRO_SUSPENDED
  PRO_UNSUSPENDED
  PRO_APPROVED
  ORDER_STATUS_FORCED
  PAYMENT_SYNCED
  PAYOUT_CREATED
  PAYOUT_SENT
  USER_ROLE_CHANGED
  CHAT_CONTACT_INFO_DETECTED
}

enum OrderStatus {
  draft
  pending_pro_confirmation
  accepted
  confirmed
  in_progress
  awaiting_client_approval
  disputed
  completed
  paid
  canceled
}

enum OrderLineItemType {
  labor
  platform_fee
  tax
  tip
  discount
  adjustment
  cancellation_fee
}

enum TaxBehavior {
  taxable
  non_taxable
  tax_included
}

enum PricingMode {
  hourly
  fixed
}

// How payment is captured for an order (single_capture = full amount at completion; reserve for future: deposit_balance, milestones)
enum PaymentStrategy {
  single_capture
  // deposit_balance
  // milestones
}

enum ApprovalMethod {
  client_accepted
  auto_accepted
  admin_adjusted
}

enum DisputeStatus {
  none
  open
  resolved
  canceled
}

enum ChatSenderRole {
  client
  pro
  admin
  system
}

enum ChatMessageType {
  user
  system
}

model User {
  id        String    @id @default(cuid())
  role      Role      @default(client)
  deletedAt DateTime?
  createdAt DateTime  @default(now())

  // Relations
  proProfile    ProProfile?
  clientProfile ClientProfile?
  ordersAsClient   Order[]   @relation("ClientOrders")
  reviewsAsClient  Review[]   @relation("ClientReviews")
  paymentsAsClient Payment[] @relation("ClientPayments")
  messagesSent     OrderMessage[]
  threadStates     OrderThreadState[]

  @@index([role])
  @@index([deletedAt])
  @@map("users")
}

model ProProfile {
  id          String     @id @default(cuid())
  userId      String     @unique
  displayName String
  email       String
  phone       String?
  bio         String?
  avatarUrl   String?
  hourlyRate  Float
  serviceArea      String?  // Derived from base address geocode (department) for display only
  serviceRadiusKm  Int      @default(10)  // Radius in km; client within radius is shown in search
  baseCountryCode  String?
  baseLatitude     Float?
  baseLongitude    Float?
  basePostalCode   String?
  baseAddressLine  String?
  status      ProStatus  @default(pending)
  profileCompleted Boolean @default(false)
  completedJobsCount Int   @default(0)
  isTopPro    Boolean    @default(false)
  responseTimeMinutes Int?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  availability Availability[]
  orders      Order[]      @relation("ProOrders")
  reviews     Review[]
  payments    Payment[]
  payoutProfile ProPayoutProfile?
  earnings    Earning[]
  payouts     Payout[]
  categoryRelations ProProfileCategory[] // New junction table relation

  @@index([userId])
  @@index([status])
  @@index([profileCompleted])
  @@index([isTopPro])
  @@index([status, profileCompleted])
  @@map("pro_profiles")
}

model ClientProfile {
  id                    String                 @id @default(cuid())
  userId                String                 @unique
  firstName             String?
  lastName              String?
  email                 String?
  phone                 String?
  avatarUrl             String?
  preferredContactMethod PreferredContactMethod?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("client_profiles")
}

model Availability {
  id           String   @id @default(cuid())
  proProfileId String
  dayOfWeek    Int      // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  startTime    String   // Format: "HH:MM" (e.g., "09:00")
  endTime      String   // Format: "HH:MM" (e.g., "17:00")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  proProfile ProProfile @relation(fields: [proProfileId], references: [id], onDelete: Cascade)

  @@index([proProfileId])
  @@map("availabilities")
}

model Order {
  id                        String        @id @default(cuid())
  displayId                 String        @unique
  clientUserId              String
  proProfileId              String?
  categoryId                String        // FK to Category table (required)
  subcategoryId             String?
  categoryMetadataJson      Json?         // Answers to dynamic questions from config
  
  // Job details
  title                     String?
  description               String?
  addressText               String
  addressLat                Float?
  addressLng                Float?
  scheduledWindowStartAt     DateTime
  scheduledWindowEndAt      DateTime?
  
  // Lifecycle
  status                    OrderStatus   @default(pending_pro_confirmation)
  acceptedAt                DateTime?
  confirmedAt               DateTime?
  startedAt                 DateTime?
  arrivedAt                 DateTime?
  completedAt               DateTime?
  paidAt                    DateTime?
  canceledAt                DateTime?
  cancelReason              String?
  
  // Pricing snapshots
  pricingMode               PricingMode   @default(hourly)
  hourlyRateSnapshotAmount  Float
  currency                  String        @default("UYU")
  minHoursSnapshot          Float?
  
  // Quote (fixed-price flow)
  quotedAmountCents        Int?
  quotedAt                 DateTime?
  quoteMessage             String?
  quoteAcceptedAt          DateTime?

  // Hours
  estimatedHours            Float?       // Optional for fixed; use 0 or null when pricingMode is fixed
  finalHoursSubmitted      Float?
  approvedHours             Float?
  approvalMethod            ApprovalMethod?
  approvalDeadlineAt        DateTime?
  
  // Totals (cached)
  subtotalAmount            Float?        // labor pre-tax
  platformFeeAmount         Float?
  taxAmount                 Float?        // IVA total
  totalAmount               Float?
  totalsCalculatedAt        DateTime?
  
  // Tax snapshot
  taxScheme                 String?       @default("iva")
  taxRate                   Float?       // e.g. 0.22
  taxIncluded               Boolean      @default(false)
  taxRegion                 String?      @default("UY")
  taxCalculatedAt           DateTime?
  
  // Dispute fields
  disputeStatus             DisputeStatus @default(none)
  disputeReason             String?
  disputeOpenedBy           String?      // client/pro/admin user ID
  
  // Metadata
  isFirstOrder            Boolean      @default(false)
  photoUrlsJson           Json?        // Order photos from create job wizard (array of storage URLs)
  workProofPhotoUrlsJson   Json?        // Work proof photos from pro on completion (array of storage URLs)
  createdAt                 DateTime     @default(now())
  updatedAt                 DateTime     @updatedAt

  // Relations
  client                    User         @relation("ClientOrders", fields: [clientUserId], references: [id], onDelete: Cascade)
  proProfile                ProProfile?  @relation("ProOrders", fields: [proProfileId], references: [id], onDelete: SetNull)
  subcategory               Subcategory? @relation("OrderSubcategory", fields: [subcategoryId], references: [id], onDelete: SetNull)
  category                  Category     @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  lineItems                 OrderLineItem[]
  review                    Review?
  payment                   Payment?
  earning                   Earning?
  messages                  OrderMessage[]
  threadStates              OrderThreadState[]
  
  @@index([clientUserId])
  @@index([proProfileId])
  @@index([status])
  @@index([scheduledWindowStartAt])
  @@index([categoryId])
  @@index([subcategoryId])
  @@index([categoryId, subcategoryId])
  @@index([displayId])
  @@map("orders")
}

model OrderLineItem {
  id          String            @id @default(cuid())
  orderId     String
  type        OrderLineItemType
  description String
  quantity    Float             // decimal; hours for labor
  unitAmount  Float             // amount per unit
  amount      Float             // quantity * unitAmount
  currency    String            @default("UYU")
  taxBehavior TaxBehavior?
  taxRate     Float?            // optional per line
  metadata    Json?             // flexible metadata
  createdAt   DateTime          @default(now())
  
  // Relations
  order       Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@index([orderId])
  @@index([type])
  @@map("order_line_items")
}

model Receipt {
  id                 String   @id @default(cuid())
  orderId            String   @unique
  lineItems          Json     // array of { type, description, amount } (minor units)
  laborAmount        Float    // minor units
  platformFeeAmount  Float    // minor units
  platformFeeRate    Float
  taxAmount          Float    // minor units
  taxRate            Float
  subtotalAmount     Float    // minor units
  totalAmount        Float    // minor units
  currency           String   @default("UYU")
  finalizedAt        DateTime
  approvedHours      Float?   // hours used for final calculation
  createdAt          DateTime @default(now())

  @@index([orderId])
  @@map("receipts")
}

model OrderMessage {
  id              String          @id @default(cuid())
  orderId         String
  senderUserId    String?
  senderRole      ChatSenderRole  @default(system)
  type            ChatMessageType @default(user)
  text            String
  attachmentsJson Json?
  createdAt       DateTime        @default(now())

  // Relations
  order  Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  sender User?  @relation(fields: [senderUserId], references: [id], onDelete: SetNull)

  @@index([orderId, createdAt])
  @@index([senderUserId])
  @@map("order_messages")
}

model OrderThreadState {
  id         String   @id @default(cuid())
  orderId    String
  userId     String
  lastReadAt DateTime?
  mutedUntil DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orderId, userId])
  @@index([userId])
  @@index([orderId])
  @@map("order_thread_states")
}

model Review {
  id           String   @id @default(cuid())
  orderId      String   @unique
  proProfileId String
  clientUserId String
  rating       Int      // 1-5
  comment      String?
  createdAt    DateTime @default(now())

  // Relations
  order      Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  proProfile ProProfile @relation(fields: [proProfileId], references: [id], onDelete: Cascade)
  client     User       @relation("ClientReviews", fields: [clientUserId], references: [id], onDelete: Cascade)

  @@index([proProfileId])
  @@index([clientUserId])
  @@index([orderId])
  @@map("reviews")
}

model Payment {
  id                String         @id @default(cuid())
  provider          PaymentProvider
  type              PaymentType
  status            PaymentStatus  @default(CREATED)
  orderId           String        @unique
  clientUserId      String
  proProfileId      String?
  currency          String        // e.g. "UYU"
  amountEstimated   Int           // minor units
  amountAuthorized  Int?          // minor units
  amountCaptured    Int?          // minor units
  providerReference String?       // e.g. preferenceId / paymentId
  checkoutUrl       String?       // for redirect flows
  idempotencyKey    String        @unique
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  order      Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  client     User           @relation("ClientPayments", fields: [clientUserId], references: [id], onDelete: Cascade)
  proProfile ProProfile?    @relation(fields: [proProfileId], references: [id], onDelete: SetNull)
  events     PaymentEvent[]

  @@index([orderId])
  @@index([providerReference])
  @@index([idempotencyKey])
  @@map("payments")
}

model PaymentEvent {
  id              String         @id @default(cuid())
  paymentId       String
  provider        PaymentProvider
  eventType       String
  raw             Json
  createdAt       DateTime       @default(now())

  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([createdAt])
  @@map("payment_events")
}

model NotificationDelivery {
  id                String                     @id @default(cuid())
  channel           NotificationChannel
  recipientRef      String
  templateId        String
  payload           Json
  idempotencyKey    String                     @unique
  provider          String?
  providerMessageId String?
  status            NotificationDeliveryStatus @default(QUEUED)
  error             String?
  attemptCount      Int                        @default(0)
  lastAttemptAt     DateTime?
  createdAt         DateTime                   @default(now())
  sentAt            DateTime?
  failedAt          DateTime?

  @@index([status])
  @@index([channel, recipientRef])
  @@index([createdAt])
  @@map("notification_deliveries")
}

model DevicePushToken {
  id         String         @id @default(cuid())
  userId     String
  provider   PushProvider   @default(EXPO)
  platform   DevicePlatform
  token      String         @unique
  isActive   Boolean        @default(true)
  lastSeenAt DateTime?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@index([userId])
  @@index([isActive])
  @@map("device_push_tokens")
}

model ProPayoutProfile {
  id                String       @id @default(cuid())
  proProfileId      String       @unique
  payoutMethod      PayoutMethod @default(BANK_TRANSFER)
  fullName          String?
  documentId        String?
  bankName          String?
  bankAccountType   String?
  bankAccountNumber String?      // TODO: Encrypt this field
  currency          String       @default("UYU")
  isComplete        Boolean      @default(false)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Relations
  proProfile ProProfile @relation(fields: [proProfileId], references: [id], onDelete: Cascade)

  @@index([proProfileId])
  @@map("pro_payout_profiles")
}

model Earning {
  id              String        @id @default(cuid())
  orderId         String        @unique
  proProfileId    String
  clientUserId    String
  currency        String
  grossAmount     Int           // minor units
  platformFeeAmount Int         // minor units
  netAmount       Int           // minor units
  status          EarningStatus @default(PENDING)
  availableAt     DateTime?     // when becomes PAYABLE (cooling-off)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  order      Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  proProfile ProProfile @relation(fields: [proProfileId], references: [id], onDelete: Cascade)
  payoutItem PayoutItem?

  @@index([proProfileId])
  @@index([status])
  @@index([availableAt])
  @@index([orderId])
  @@map("earnings")
}

model Payout {
  id               String         @id @default(cuid())
  proProfileId     String
  provider         PayoutProvider
  status           PayoutStatus   @default(CREATED)
  currency         String
  amount           Int            // sum of earnings (minor units)
  providerReference String?
  failureReason    String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  sentAt           DateTime?
  settledAt        DateTime?

  // Relations
  proProfile ProProfile  @relation(fields: [proProfileId], references: [id], onDelete: Cascade)
  items      PayoutItem[]

  @@index([proProfileId])
  @@index([status])
  @@map("payouts")
}

model PayoutItem {
  id        String   @id @default(cuid())
  payoutId  String
  earningId String   @unique
  amount    Int      // minor units
  createdAt DateTime @default(now())

  // Relations
  payout  Payout  @relation(fields: [payoutId], references: [id], onDelete: Cascade)
  earning Earning @relation(fields: [earningId], references: [id], onDelete: Cascade)

  @@index([payoutId])
  @@index([earningId])
  @@map("payout_items")
}

model AuditLog {
  id            String         @id @default(cuid())
  eventType     AuditEventType
  actorId       String         // Who performed the action (admin user ID)
  actorRole     Role           // Admin role for quick filtering
  resourceType  String         // "pro", "order", "payment", "payout", etc.
  resourceId    String         // ID of the affected resource
  action        String         // "suspend", "force_status", "sync", etc.
  metadata      Json?          // Flexible: reason, oldStatus, newStatus, etc.
  ipAddress     String?        // Request IP (from context)
  userAgent     String?        // User agent (from context)
  createdAt     DateTime       @default(now())

  @@index([eventType])
  @@index([resourceType, resourceId])
  @@index([actorId])
  @@index([createdAt])
  @@map("audit_logs")
}


// Category table - data-driven categories with soft delete
model Category {
  id               String           @id @default(cuid())
  key              String           // Stable identifier like "PLUMBING"
  name             String           // Display name (migrated from CategoryMetadata.displayName)
  slug             String
  iconName         String?          // e.g., "Wrench" (for Lucide icons) - migrated from CategoryMetadata.iconName
  description      String?          // Migrated from CategoryMetadata.description
  sortOrder        Int              @default(0) // Migrated from CategoryMetadata.displayOrder
  pricingMode      PricingMode      @default(hourly)
  paymentStrategy  PaymentStrategy  @default(single_capture)
  isActive         Boolean          @default(true)
  deletedAt        DateTime?        // Soft delete timestamp
  configJson       Json?            // Category-level UI defaults
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  fts              Unsupported("tsvector")? // FTS; maintained by DB trigger, GIN index in migration
  searchable_text  String?                 // Trigram search; trigger + GIN(gin_trgm_ops) in migration only

  // Relations
  subcategories Subcategory[]
  orders        Order[]
  proProfiles   ProProfileCategory[]

  @@index([fts], type: Gin) // GIN for full-text search on tsvector
  @@index([searchable_text(ops: raw("gin_trgm_ops"))], type: Gin, map: "idx_categories_searchable_text_gin")
  @@index([isActive, sortOrder])
  @@index([deletedAt])
  @@map("categories")
}

model Subcategory {
  id          String   @id @default(cuid())
  name        String
  slug        String
  categoryId  String   // FK to Category table (required)
  key         String?  // Stable identifier within category (e.g. "UNCLOG_DRAIN")
  imageUrl    String?
  description String?
  displayOrder Int     @default(0)
  isActive    Boolean  @default(true)
  configJson  Json?    // Subcategory-level UI config (overrides category config)
  searchKeywords String[] @default([]) // Search keywords for this subcategory
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  fts             Unsupported("tsvector")? // FTS; maintained by DB trigger, GIN index in migration
  searchable_text String?                  // Trigram search; trigger + GIN(gin_trgm_ops) in migration only

  // Relations
  category    Category  @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  orders      Order[]   @relation("OrderSubcategory")

  @@unique([categoryId, slug]) // Unique slug within category
  @@unique([categoryId, key]) // Unique key within category
  @@index([fts], type: Gin) // GIN for full-text search on tsvector
  @@index([searchable_text(ops: raw("gin_trgm_ops"))], type: Gin, map: "idx_subcategories_searchable_text_gin")
  @@index([categoryId])
  @@index([slug])
  @@index([isActive])
  @@index([categoryId, isActive, displayOrder])
  @@map("subcategories")
}

model ProProfileCategory {
  id                String     @id @default(cuid())
  proProfileId      String
  categoryId        String
  hourlyRateCents   Int?       // For hourly categories: rate in minor units
  startingFromCents Int?       // For fixed categories: "starting from" price in minor units
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  proProfile  ProProfile @relation(fields: [proProfileId], references: [id], onDelete: Cascade)
  category    Category   @relation(fields: [categoryId], references: [id], onDelete: Restrict)

  @@unique([proProfileId, categoryId])
  @@index([categoryId])
  @@index([proProfileId])
  @@map("pro_profile_categories")
}
